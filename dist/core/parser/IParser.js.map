{"version":3,"sources":["../../../src/core/parser/IParser.js"],"names":["_config","Symbol","_queue","rest","contentType","dataType","sleep","ms","Promise","setTimeout","resolve","IParser","config","content_store","constructor","TypeError","searchBook","prototype","searchChapters","parseContent","prevChapter","nextChapter","data","parseJob","interval","Math","ceil","random","getKey","bind","getConfig","get","start","obainHtml","findBook","findChapters","syncChapters","syncAllContent","syncContent","key","link","params","GET","headers","getRandom","err","console","error","bookId","qdBookInfo","bookInfo","book","BookId","bookName","BookName","waitAll","log","chapter","chapterLink","text","collection","insert","_id","id","chapterId","type","title","content","save","chapters","latestChapter","length","findOne","result","find","sort","toArray","name","oldChapterIds","list","forEach","oldChapter","push","duplicateIds","needToPersist","filter","indexOf","map","index","insertMany","chapterid","oldChapterTextIds","addData"],"mappings":"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","file":"IParser.js","sourcesContent":["\nimport Rest from 'react-rest-kit';\nimport randomUseragent from 'random-useragent';\n\nimport QidianClient from '../../qidian.client';\nimport { db } from '../../db';\nimport Queue from '../queue';\n\nconst _config = Symbol('config');\nconst _queue = Symbol('queue');\n\nconst rest = new Rest({\n  contentType: 'application/json',\n  dataType: 'text',\n});\n\nconst sleep = (ms) => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nclass IParser {\n  constructor({\n    config,\n    content_store = false,  // 默认不存储文章内容\n  }) {\n    if (this.constructor === IParser) {\n      throw new TypeError(\"Can not construct abstract class.\");\n    }\n    if (this.searchBook === IParser.prototype.searchBook) {\n      throw new TypeError(\"Please implement abstract method searchBook.\");\n    }\n    if (this.searchChapters === IParser.prototype.searchChapters) {\n      throw new TypeError(\"Please implement abstract method searchChapters.\");\n    }\n    if (this.parseContent === IParser.prototype.parseContent) {\n      throw new TypeError(\"Please implement abstract method parseContent.\");\n    }\n    if (this.prevChapter === IParser.prototype.prevChapter) {\n      throw new TypeError(\"Please implement abstract method prevChapter.\");\n    }\n    if (this.nextChapter === IParser.prototype.nextChapter) {\n      throw new TypeError(\"Please implement abstract method nextChapter.\");\n    }\n\n    this[_config] = config;\n    this[_queue] = new Queue((data) => {\n      this.parseJob(data);\n    }, {\n        interval: () => {\n          return Math.ceil((Math.random() * 100 + 100) * 100);\n        }\n      });\n    this.content_store = content_store;\n\n    this.getKey = this.getKey.bind(this);\n    this.getConfig = this.getConfig.bind(this);\n\n    this.get = this.get.bind(this);\n    this.start = this.start.bind(this);\n    this.obainHtml = this.obainHtml.bind(this);\n    this.searchBook = this.searchBook.bind(this);\n    this.searchChapters = this.searchChapters.bind(this);\n    this.parseJob = this.parseJob.bind(this);\n    this.parseContent = this.parseContent.bind(this);\n    this.prevChapter = this.prevChapter.bind(this);\n    this.nextChapter = this.nextChapter.bind(this);\n\n    this.findBook = this.findBook.bind(this);\n    this.findChapters = this.findChapters.bind(this);\n    this.syncChapters = this.syncChapters.bind(this);\n    this.syncAllContent = this.syncAllContent.bind(this);\n    this.syncContent = this.syncContent.bind(this);\n  }\n\n  getKey() {\n    return this.getConfig().key;\n  }\n\n  getConfig() {\n    return this[_config];\n  }\n\n  async get(link, params) {\n    const { data, err } = await rest.GET(link, params, {\n      headers: {\n        'User-Agent': randomUseragent.getRandom(),\n      },\n    });\n    if (err) {\n      console.error('request get failed ', err);\n      return null;\n    }\n\n    return data;\n  }\n\n  /**\n   * 开始解析\n   */\n  async start({ bookId }) {\n    // 获取图书信息\n    const { qdBookInfo, bookInfo } = await this.findBook(bookId);\n\n    const book = {\n      bookId: `${qdBookInfo.BookId}`,\n      bookName: qdBookInfo.BookName,\n      link: bookInfo.link,\n    };\n\n    // 获取并存储章节列表\n    await this.findChapters(book);\n\n    if (!this.content_store) {\n      await this[_queue].waitAll();\n      return true;\n    }\n\n    // 缓存章节内容\n    await syncContent(book);\n\n  }\n\n  /**\n   * 根据连接获取html代码\n   * @param {*} link \n   * @param {*} params\n   */\n  async obainHtml(link, params = {}) {\n    console.log('[IParser] start obain html ', link, params);\n    return await this.get(link, params);\n  }\n\n  async parseJob({ chapter, book }) {\n    console.log('[IParser] 开始解析文章内容');\n    if (!chapter || !book) {\n      console.log('[IParser] 解析文章内容失败，缺少必要参数');\n      return false;\n    }\n\n    const { bookId, bookName } = book;\n\n    // const chapterLink = `${book.link.endsWith('/') ? book.link : `${book.link}/`}${chapter.link}`;\n    const chapterLink = chapter.link;\n    console.log('[IParser] 解析文章内容来自', chapterLink);\n    const text = await this.parseContent(chapterLink);\n    if (!text) {\n      // 该章节内容为空\n      // TODO 通知管理员，可以进行章节更换\n      return false;\n    }\n\n    console.log('[IParser] parse success, start persist data into db');\n    await db().collection('book_chapter_text').insert({\n      _id: `${chapter.id}_${this.getConfig().key}`,\n      chapterId: `${chapter.id}`,\n      type: this.getConfig().key,\n      bookId: `${book.bookId}`,\n      bookName: book.bookName,\n      title: chapter.title,\n      content: text,\n    });\n  }\n\n  /**\n   * 搜索图书信息\n   */\n  searchBook(bookName) { }\n\n  /**\n   * 搜索章节\n   */\n  searchChapters(link) { }\n\n  /**\n   * 解析HTML章节内容\n   */\n  parseContent(link) { }\n\n  // ==================== public =========================\n\n  /**\n   * 查找书籍\n   */\n  async findBook(bookId) {\n    // 获取起点图书信息\n    const { data: qdBookInfo, err } = await QidianClient.bookInfo({ bookId });\n    if (err) {\n      // 获取起点图书信息失败\n      // TODO 重新加入缓存队列，等待重新尝试解析\n      console.error('[IParser] 获取起点图书信息失败', err);\n      return false;\n    }\n\n    // 搜索图书信息\n    const bookInfo = await this.searchBook(qdBookInfo.BookName);\n    if (!bookInfo) {\n      // 不存在该本书的信息\n      // TODO 发送通知，提醒该书不存在\n      console.error('[IParser] 获取源站图书信息失败，该书不存在');\n      return false;\n    }\n\n    // 存储图书信息\n    try {\n      await db().collection('book').save({\n        ...bookInfo,\n        bookId: `${qdBookInfo.BookId}`,\n        type: this.getConfig().key,\n        _id: `${qdBookInfo.BookId}_${this.getConfig().key}`,\n      });\n    } catch (dberr1) {\n      if (dberr1) {\n        console.error('[IParser] 持久化图书信息失败', dberr1);\n        return false;\n      }\n    }\n\n    return {\n      qdBookInfo,\n      bookInfo,\n    }\n  }\n\n  async findChapters({\n    bookId,\n  }) {\n    if (!bookId) {\n      throw '[IParser] 查询章节缺少必要的图书编号';\n    }\n\n    // 获取最新章节\n    const { data, err } = await QidianClient.chapters({\n      bookId: bookId,\n    });\n\n    if (err) {\n      throw '[IParser] 查询章节，同步最新列表失败';\n    }\n\n    const latestChapter = data[data.length - 1];\n    const result = await db().collection('book_chapters').findOne({ title: latestChapter, type: this.getKey() });\n    if (!result) {\n      // 最新章节不相同\n      await this.syncChapters({ bookId });\n    }\n    console.log('start sync chapters');\n    return await db().collection('book_chapters').find({ type: this.getKey() }).sort({ sort: 1 }).toArray();\n  }\n\n  async syncChapters({\n    bookId,   // required\n    bookName,\n    link,\n  }) {\n    if (!bookId) {\n      throw '[IParser] 查询章节缺少必要的图书编号';\n    }\n\n    if (!bookName || !link) {\n      // 从数据库中获取图书信息\n      const book = await db().collection('book').findOne({ bookId, type: this.getConfig().key });\n      if (book) {\n        bookName = book.name;\n        link = book.link;\n      } else {\n        // 数据库中不存在则从网络中抓取并缓存\n        const { qdBookInfo, bookInfo } = await this.findBook(bookId);\n        bookName = qdBookInfo.BookName;\n        link = bookInfo.link;\n      }\n    }\n\n    // 获取老的章节列表\n    let oldChapterIds = [];\n    try {\n      const list = await db().collection('book_chapters').find({ bookId, type: this.getConfig().key }, { _id: 1 }).toArray();\n      list.forEach((oldChapter) => {\n        oldChapterIds.push(oldChapter._id);\n      });\n    } catch (dberr4) {\n      if (dberr4) {\n        console.error('[IParser] 获取图书章节失败', dberr4);\n        return false;\n      }\n    }\n\n    // 搜索该图书的章节列表\n    const chapters = await this.searchChapters(link);\n\n    // 存储新的章节信息\n    let duplicateIds = [];\n    const needToPersist = chapters\n      .filter(chapter => {\n        if (oldChapterIds.indexOf(`${chapter.id}_${this.getConfig().key}`) === -1 && duplicateIds.indexOf(`${chapter.id}_${this.getConfig().key}`) === -1) {\n          duplicateIds.push(`${chapter.id}_${this.getConfig().key}`);\n          return true;\n        }\n        return false;\n      })\n      .map((chapter, index) => {\n        return {\n          _id: `${chapter.id}_${this.getConfig().key}`,\n          chapterId: `${chapter.id}`,\n          type: this.getConfig().key,\n          bookId: `${bookId}`,\n          bookName,\n          title: chapter.title,\n          link: chapter.link,\n          sort: index + 1,\n        };\n      });\n    try {\n      needToPersist.length && await db().collection('book_chapters').insertMany(needToPersist);\n    } catch (dberr2) {\n      if (dberr2) {\n        console.error('[IParser] 持久化图书章节失败', dberr2);\n        return false;\n      }\n    }\n    console.log('[IParser] 持久化图书章节成功');\n\n    return needToPersist;\n  }\n\n  async syncContent({\n    chapterId,\n  }) {\n    if (!chapterId) {\n      throw `[IParser] 同步图书章节缺少chapterId`;\n    }\n\n    const chapter = await db().collection('book_chapters').findOne({ chapterId: chapterId, type: this.getKey() });\n    if (!chapter) {\n      throw `[IParser] 未找到章节${chapterid}`;\n    }\n\n    let book = await db().collection('book').findOne({ bookId: chapter.bookId, type: this.getKey() });\n    if (!book) {\n      const { qdBookInfo, bookInfo } = await this.findBook(chapter.bookId);\n      book = {\n        bookId: qdBookInfo.BookId,\n        bookName: qdBookInfo.BookName,\n        link: bookInfo.link,\n      };\n    }\n\n    await this.parseJob({\n      chapter: {\n        id: chapterId,\n        title: chapter.title,\n        link: chapter.link,\n      },\n      book,\n    });\n\n    return await db().collection('book_chapter_text').findOne({ chapterId, type: this.getKey() });\n  }\n\n  async syncAllContent({\n    bookId,\n    bookName,\n  }) {\n    // 不考虑图书不存在的情况，如果不存在则说明数据同步存在问题\n    if (!bookId || !bookName) {\n      throw '[IParser] 同步图书所有文章内容缺少bookId或者bookName参数';\n    }\n\n    // 获取已缓存章节内容\n    let oldChapterTextIds = [];\n    try {\n      const list = await db().collection('book_chapters_text').find({ bookId, type: this.getConfig().key }, { _id: 1 }).toArray();\n      list.forEach((oldChapter) => {\n        oldChapterTextIds.push(oldChapter._id);\n      });\n    } catch (dberr5) {\n      if (dberr5) {\n        console.error('[IParser] 获取图书内容失败', dberr5);\n        return false;\n      }\n    }\n\n    // 根据章节列表下载章节内容\n    // 存储章节内容至数据库\n    try {\n      chapters\n        .filter(chapter => oldChapterTextIds.indexOf(`${chapter.id}_${this.getConfig().key}`) === -1)\n        .forEach((chapter) => {\n          this[_queue].addData({\n            chapter,\n            book: {\n              bookId: `${bookId}`,\n              bookName,\n            },\n          });\n        });\n    } catch (dberr3) {\n      if (dberr3) {\n        console.error('[IParser] 加入任务队列失败', dberr3);\n        return false;\n      }\n    }\n\n    console.log('[IParser] 加入任务队列成功');\n\n    await this[_queue].waitAll();\n  }\n\n  /**\n   * 上一章节\n   */\n  prevChapter() { }\n\n  /**\n   * 下一章节\n   */\n  nextChapter() { }\n\n}\n\n\nexport default IParser;\n"]}