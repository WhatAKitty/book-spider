{"version":3,"sources":["../../../src/core/parser/IParser.js"],"names":["_config","Symbol","_queue","rest","contentType","dataType","sleep","ms","Promise","setTimeout","resolve","IParser","config","content_store","constructor","TypeError","searchBook","prototype","searchChapters","parseContent","prevChapter","nextChapter","data","parseJob","interval","Math","ceil","random","getKey","bind","getConfig","obain","start","obainHtml","findBook","findChapters","syncChapters","syncAllContent","syncContent","key","link","params","method","another","options","headers","getRandom","qsStringifyOptions","encodeURIComponent","uri","result","GET","err","console","error","bookId","qdBookInfo","bookInfo","book","BookId","bookName","BookName","waitAll","log","chapter","chapterLink","text","collection","insert","_id","id","chapterId","type","title","content","save","chapters","latestChapter","Chapters","length","findOne","n","find","sort","toArray","name","oldChapterIds","list","forEach","oldChapter","push","duplicateIds","needToPersist","filter","indexOf","map","index","insertMany","chapterid","chapterContent","oldChapterTextIds","addData"],"mappings":"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","file":"IParser.js","sourcesContent":["\nimport Rest from 'react-rest-kit';\nimport randomUseragent from 'random-useragent';\n\nimport QidianClient from '../../qidian.client';\nimport { db } from '../../db';\nimport Queue from '../queue';\n\nconst _config = Symbol('config');\nconst _queue = Symbol('queue');\n\nconst rest = new Rest({\n  contentType: 'application/json',\n  dataType: 'text',\n});\n\nconst sleep = (ms) => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nclass IParser {\n  constructor({\n    config,\n    content_store = false,  // 默认不存储文章内容\n  }) {\n    if (this.constructor === IParser) {\n      throw new TypeError(\"Can not construct abstract class.\");\n    }\n    if (this.searchBook === IParser.prototype.searchBook) {\n      throw new TypeError(\"Please implement abstract method searchBook.\");\n    }\n    if (this.searchChapters === IParser.prototype.searchChapters) {\n      throw new TypeError(\"Please implement abstract method searchChapters.\");\n    }\n    if (this.parseContent === IParser.prototype.parseContent) {\n      throw new TypeError(\"Please implement abstract method parseContent.\");\n    }\n    if (this.prevChapter === IParser.prototype.prevChapter) {\n      throw new TypeError(\"Please implement abstract method prevChapter.\");\n    }\n    if (this.nextChapter === IParser.prototype.nextChapter) {\n      throw new TypeError(\"Please implement abstract method nextChapter.\");\n    }\n\n    this[_config] = config;\n    this[_queue] = new Queue((data) => {\n      this.parseJob(data);\n    }, {\n        interval: () => {\n          return Math.ceil((Math.random() * 100 + 100) * 100);\n        }\n      });\n    this.content_store = content_store;\n\n    this.getKey = this.getKey.bind(this);\n    this.getConfig = this.getConfig.bind(this);\n\n    this.obain = this.obain.bind(this);\n    this.start = this.start.bind(this);\n    this.obainHtml = this.obainHtml.bind(this);\n    this.searchBook = this.searchBook.bind(this);\n    this.searchChapters = this.searchChapters.bind(this);\n    this.parseJob = this.parseJob.bind(this);\n    this.parseContent = this.parseContent.bind(this);\n    this.prevChapter = this.prevChapter.bind(this);\n    this.nextChapter = this.nextChapter.bind(this);\n\n    this.findBook = this.findBook.bind(this);\n    this.findChapters = this.findChapters.bind(this);\n    this.syncChapters = this.syncChapters.bind(this);\n    this.syncAllContent = this.syncAllContent.bind(this);\n    this.syncContent = this.syncContent.bind(this);\n  }\n\n  getKey() {\n    return this.getConfig().key;\n  }\n\n  getConfig() {\n    return this[_config];\n  }\n\n  async obain(link, params, method = 'GET', another = {}) {\n    const options = {\n      ...another,\n      headers: {\n        'User-Agent': randomUseragent.getRandom(),\n        ...(another.headers || {}),\n      },\n      qsStringifyOptions: {\n        encodeURIComponent: uri => uri,     // with no encode\n      },\n    }\n\n    let result = {};\n    if (method === 'POST') {\n      result = await rest.rest(link, options);\n    } else {\n      result = await rest.GET(link, params, options);\n    }\n\n\n    if (result.err) {\n      console.error('request get failed ', err);\n      return null;\n    }\n\n    return result.data;\n  }\n\n  /**\n   * 开始解析\n   */\n  async start({ bookId }) {\n    // 获取图书信息\n    const { qdBookInfo, bookInfo } = await this.findBook(bookId);\n\n    const book = {\n      bookId: `${qdBookInfo.BookId}`,\n      bookName: qdBookInfo.BookName,\n      link: bookInfo.link,\n    };\n\n    // 获取并存储章节列表\n    await this.findChapters(book);\n\n    if (!this.content_store) {\n      await this[_queue].waitAll();\n      return true;\n    }\n\n    // 缓存章节内容\n    await syncContent(book);\n\n  }\n\n  /**\n   * 根据连接获取html代码\n   * @param {*} link \n   * @param {*} params\n   */\n  async obainHtml(link, params = {}, method, options) {\n    console.log('[IParser] start obain html ', link, params);\n    return await this.obain(link, params, method, options);\n  }\n\n  async parseJob({ chapter, book }) {\n    console.log('[IParser] 开始解析文章内容');\n    if (!chapter || !book) {\n      console.log('[IParser] 解析文章内容失败，缺少必要参数');\n      return false;\n    }\n\n    const { bookId, bookName } = book;\n\n    // const chapterLink = `${book.link.startsWith('/') ? book.link : `${book.link}/`}${chapter.link}`;\n    const chapterLink = chapter.link;\n    console.log('[IParser] 解析文章内容来自', chapterLink);\n    const text = await this.parseContent(chapterLink);\n    if (!text) {\n      // 该章节内容为空\n      // TODO 通知管理员，可以进行章节更换\n      return false;\n    }\n\n    console.log('[IParser] parse success, start persist data into db');\n    await db().collection('book_chapter_text').insert({\n      _id: `${chapter.id}_${this.getConfig().key}`,\n      chapterId: `${chapter.id}`,\n      type: this.getConfig().key,\n      bookId: `${book.bookId}`,\n      bookName: book.bookName,\n      title: chapter.title,\n      content: text,\n    });\n  }\n\n  /**\n   * 搜索图书信息\n   */\n  searchBook(bookName) { }\n\n  /**\n   * 搜索章节\n   */\n  searchChapters(link) { }\n\n  /**\n   * 解析HTML章节内容\n   */\n  parseContent(link) { }\n\n  // ==================== public =========================\n\n  /**\n   * 查找书籍\n   */\n  async findBook(bookId) {\n    // 获取起点图书信息\n    const { data: qdBookInfo, err } = await QidianClient.bookInfo({ bookId });\n    if (err) {\n      // 获取起点图书信息失败\n      // TODO 重新加入缓存队列，等待重新尝试解析\n      console.error('[IParser] 获取起点图书信息失败', err);\n      return false;\n    }\n\n    // 搜索图书信息\n    const bookInfo = await this.searchBook(qdBookInfo.BookName);\n    if (!bookInfo) {\n      // 不存在该本书的信息\n      // TODO 发送通知，提醒该书不存在\n      console.error('[IParser] 获取源站图书信息失败，该书不存在');\n      return false;\n    }\n\n    // 存储图书信息\n    try {\n      await db().collection('book').save({\n        ...bookInfo,\n        bookId: `${qdBookInfo.BookId}`,\n        type: this.getConfig().key,\n        _id: `${qdBookInfo.BookId}_${this.getConfig().key}`,\n      });\n    } catch (dberr1) {\n      if (dberr1) {\n        console.error('[IParser] 持久化图书信息失败', dberr1);\n        return false;\n      }\n    }\n\n    return {\n      qdBookInfo,\n      bookInfo,\n    }\n  }\n\n  async findChapters({\n    bookId,\n  }) {\n    if (!bookId) {\n      throw '[IParser] 查询章节缺少必要的图书编号';\n    }\n\n    // 获取最新章节\n    const { data, err } = await QidianClient.chapters({\n      bookId: bookId,\n    });\n\n    if (err) {\n      throw '[IParser] 查询章节，同步最新列表失败';\n    }\n\n    const latestChapter = data.Chapters[data.Chapters.length - 1];\n    const result = latestChapter && await db().collection('book_chapters').findOne({ bookId, title: latestChapter.n, type: this.getKey() });\n    if (!result) {\n      // 最新章节不相同\n      await this.syncChapters({ bookId });\n    }\n\n    console.log('start sync chapters');\n    return await db().collection('book_chapters').find({ bookId, type: this.getKey() }).sort({ sort: 1 }).toArray();\n  }\n\n  async syncChapters({\n    bookId,   // required\n    bookName,\n    link,\n  }) {\n    if (!bookId) {\n      throw '[IParser] 查询章节缺少必要的图书编号';\n    }\n\n    if (!bookName || !link) {\n      // 从数据库中获取图书信息\n      const book = await db().collection('book').findOne({ bookId, type: this.getConfig().key });\n      if (book) {\n        bookName = book.name;\n        link = book.link;\n      } else {\n        // 数据库中不存在则从网络中抓取并缓存\n        const { qdBookInfo, bookInfo } = await this.findBook(bookId);\n        bookName = qdBookInfo.BookName;\n        link = bookInfo.link;\n      }\n    }\n\n    // 获取老的章节列表\n    let oldChapterIds = [];\n    try {\n      const list = await db().collection('book_chapters').find({ bookId, type: this.getConfig().key }, { _id: 1 }).toArray();\n      list.forEach((oldChapter) => {\n        oldChapterIds.push(oldChapter._id);\n      });\n    } catch (dberr4) {\n      if (dberr4) {\n        console.error('[IParser] 获取图书章节失败', dberr4);\n        return false;\n      }\n    }\n\n    // 搜索该图书的章节列表\n    const chapters = await this.searchChapters(link);\n\n    // 存储新的章节信息\n    let duplicateIds = [];\n    const needToPersist = chapters\n      .filter(chapter => {\n        if (oldChapterIds.indexOf(`${chapter.id}_${this.getConfig().key}`) === -1 && duplicateIds.indexOf(`${chapter.id}_${this.getConfig().key}`) === -1) {\n          duplicateIds.push(`${chapter.id}_${this.getConfig().key}`);\n          return true;\n        }\n        return false;\n      })\n      .map((chapter, index) => {\n        return {\n          _id: `${chapter.id}_${this.getConfig().key}`,\n          chapterId: `${chapter.id}`,\n          type: this.getConfig().key,\n          bookId: `${bookId}`,\n          bookName,\n          title: chapter.title,\n          link: chapter.link,\n          sort: +chapter.id,\n        };\n      });\n    try {\n      needToPersist.length && await db().collection('book_chapters').insertMany(needToPersist);\n    } catch (dberr2) {\n      if (dberr2) {\n        console.error('[IParser] 持久化图书章节失败', dberr2);\n        return false;\n      }\n    }\n    console.log('[IParser] 持久化图书章节成功');\n\n    return needToPersist;\n  }\n\n  async syncContent({\n    bookId,\n    chapterId,\n  }) {\n    if (!chapterId) {\n      throw `[IParser] 同步图书章节缺少chapterId`;\n    }\n\n    const chapter = await db().collection('book_chapters').findOne({ bookId, chapterId, type: this.getKey() });\n    if (!chapter) {\n      throw `[IParser] 未找到章节${chapterid}`;\n    }\n\n    // 通过章节获取章节内容\n    const chapterContent = await db().collection('book_chapter_text').findOne({ bookId, chapterId, type: this.getKey() }, { content: 1, title: 1, _id: 0 });\n    if (chapterContent) {\n      return chapterContent;\n    }\n\n    let book = await db().collection('book').findOne({ bookId, type: this.getKey() });\n    if (!book) {\n      const { qdBookInfo, bookInfo } = await this.findBook(bookId);\n      book = {\n        bookId: qdBookInfo.BookId,\n        bookName: qdBookInfo.BookName,\n        link: bookInfo.link,\n      };\n    }\n\n    await this.parseJob({\n      chapter: {\n        id: chapterId,\n        title: chapter.title,\n        link: chapter.link,\n      },\n      book,\n    });\n\n    return await db().collection('book_chapter_text').findOne({ bookId, chapterId, type: this.getKey() }, { content: 1, title: 1, _id: 0 });\n  }\n\n  async syncAllContent({\n    bookId,\n    bookName,\n  }) {\n    // 不考虑图书不存在的情况，如果不存在则说明数据同步存在问题\n    if (!bookId || !bookName) {\n      throw '[IParser] 同步图书所有文章内容缺少bookId或者bookName参数';\n    }\n\n    // 获取已缓存章节内容\n    let oldChapterTextIds = [];\n    try {\n      const list = await db().collection('book_chapters_text').find({ bookId, type: this.getConfig().key }, { _id: 1 }).toArray();\n      list.forEach((oldChapter) => {\n        oldChapterTextIds.push(oldChapter._id);\n      });\n    } catch (dberr5) {\n      if (dberr5) {\n        console.error('[IParser] 获取图书内容失败', dberr5);\n        return false;\n      }\n    }\n\n    // 根据章节列表下载章节内容\n    // 存储章节内容至数据库\n    try {\n      chapters\n        .filter(chapter => oldChapterTextIds.indexOf(`${chapter.id}_${this.getConfig().key}`) === -1)\n        .forEach((chapter) => {\n          this[_queue].addData({\n            chapter,\n            book: {\n              bookId: `${bookId}`,\n              bookName,\n            },\n          });\n        });\n    } catch (dberr3) {\n      if (dberr3) {\n        console.error('[IParser] 加入任务队列失败', dberr3);\n        return false;\n      }\n    }\n\n    console.log('[IParser] 加入任务队列成功');\n\n    await this[_queue].waitAll();\n  }\n\n  /**\n   * 上一章节\n   */\n  prevChapter() { }\n\n  /**\n   * 下一章节\n   */\n  nextChapter() { }\n\n}\n\n\nexport default IParser;\n"]}